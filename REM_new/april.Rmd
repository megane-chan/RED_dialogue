```{r}

rm(list=ls())

if (!requireNamespace("network", quietly = TRUE))
  install.packages("network")
if (!requireNamespace("tsna", quietly = TRUE))
  install.packages("tsna")
if (!requireNamespace("rem", quietly = TRUE))
  install.packages("rem", repos = "http://R-Forge.R-project.org")
library(relevent)
setwd("~/RProjects/SNA_REM/REM_new/")
library(dplyr)
library(tidyr)
library(caret)
library(network)
library(relevent)
library(rem)
library(dplyr)
library(ggplot2)
library(igraph)
library(ggraph)
library(RColorBrewer)

```






```{r}
# Interactions Data Frame (Edges)
high_perf_interactions <- readRDS("data/high_performance_sessions.RData") %>% select(session, sender_id, receiver_id, dialog, time)
#remove where receiver is all

# Convert the named num vectors to separate columns for IDs and names
interactions <- high_perf_interactions %>%
  mutate(
    sender_id = as.integer(sender_id),  # Convert sender_id to integer
    receiver_id = as.integer(receiver_id), # Convert receiver_id to integer
    dialog = as.factor(dialog) # Convert dialog to factor
  )



actors_attributes <- data.frame(
  id = 1:8,
  name = c("Igor", "Ashley", "Will", "Katya", "Saleh", "Oleg", "Vika", "Alex"),
  gender = c("male", "female", "male", "female", "male", "male", "female", "male")
)

# Create dummy variables for gender
dummyvars <- dummyVars(" ~ gender", data = actors_attributes)
actors_attributes <- cbind(actors_attributes, predict(dummyvars, actors_attributes)) %>%
  select(id, name, gendermale)
```


```{r}

session_dialogues <- high_perf_interactions %>%
  group_by(session) %>%
  summarise(n = n())


ggplot(session_dialogues, aes(x = factor(session), y = n, fill = factor(session))) + 
  geom_bar(stat = "identity") +
  scale_fill_brewer(palette = "Pastel1") +  
  labs(title = "Number of Dialogues Per Session (High Performance)",
       x = "Session",
       y = "Number of Dialogues",
       fill = "Session") +
  theme_minimal() + 
  theme(legend.position = "none") 

```


```{r}

dialogues_per_speaker_session <- high_perf_interactions %>%
  left_join(actors_attributes, by = c("sender_id" = "id")) %>%
  group_by(session, name) %>%
  summarise(number_of_dialogues = n(), .groups = 'drop') %>%
  arrange(session, desc(number_of_dialogues))

dialogues_summary_tibble <- as_tibble(dialogues_per_speaker_session)
print(dialogues_summary_tibble)


ggplot(dialogues_summary_tibble, aes(x = name, y = number_of_dialogues, fill = name)) + 
  geom_bar(stat = "identity") +
  facet_wrap(~session) +
  scale_fill_brewer(palette = "Pastel1") +  
  labs(subtitle = "Number of Dialogues Per Speaker Per Session (High Performance)",
       x = "Speaker",
       y = "Number of Dialogues",
       fill = "Speaker") +
  theme_minimal() + 
  theme(legend.position = "none") 

```

```{r}
# total number of dialogues by gender in each session
```

```{r}
target_session <- 2104

high_perf_interactions %>% filter(receiver_id != 0) %>% filter(session == target_session) %>% select(-session) %>% mutate(time = 1:nrow(.))  %>% select(sender_id, receiver_id, time,dialog)  %>% mutate(dialog = as.factor(dialog), sender_id = as.integer(sender_id), receiver_id = as.integer(receiver_id)) -> interactions


# renumber sender and receiver
actors_attributes %>% filter(id %in% interactions$sender_id) %>% filter(id %in% interactions$receiver_id) -> actors_attributes
head(actors_attributes)


g_subset <- graph_from_data_frame(interactions, directed = TRUE, vertices = data.frame(actors_attributes))


V(g_subset)$gender <- actors_attributes$gender[match(V(g_subset)$name, actors_attributes$name)]
V(g_subset)$name <- actors_attributes$name[match(V(g_subset)$name, actors_attributes$name)]

```

```{r}

dialog_colors <- RColorBrewer::brewer.pal(n = length(unique(interactions$dialog)), name = "Pastel2")
dialog_color_map <- setNames(dialog_colors, unique(interactions$dialog))


ggraph(g_subset, layout = 'fr') +
  geom_edge_link(aes(color = dialog), alpha = 0.7, edge_width = .2, lineend = "butt", arrow = arrow(type = 'closed', length = unit(4, 'mm'))) +
  scale_edge_color_manual(values = dialog_color_map) +
  geom_node_point(aes(color = factor(gender)), size = 4, alpha = 0.8) +
  geom_node_text(aes(label = name), repel = TRUE,  color = "black", size = 3, vjust = 1, nudge_x = -.02) +
  scale_color_manual(values = c('0' = 'red', '1' = 'cyan')) +
  theme_void() +
  labs(subtitle = "High Performing Session 2104", color = "Gender", edge_color = "Dialog") +
  theme(legend.position = "right", legend.title = element_text(size = 8))
```


etweenness Centrality: Frequency at which a node appears on the shortest paths between other nodes in the network. Nodes with high betweenness can have significant influence over information flow.
Closeness Centrality: How close a node is to all other nodes in the network (lower values indicate greater closeness).
Eigenvector Centrality: A measure of the influence of a node in a network, taking into account the centrality of its neighbors.
Clustering Coefficient: The degree to which nodes in a graph tend to cluster together.


```{r}
# Calculate network statistics
degree_stats <- degree(g_subset, mode = "all")  # Total degree for undirected graphs

betweenness_stats <- betweenness(g_subset, directed = TRUE)
closeness_stats <- closeness(g_subset)
eigenvector_stats <- eigen_centrality(g_subset)$vector
clustering_coefficient <- transitivity(g_subset, type = "localaverage")


network_stats_summary <- data.frame(
  name = V(g_subset)$name,
  degree = degree_stats,
  betweenness = betweenness_stats,
  closeness = closeness_stats,
  eigenvector = eigenvector_stats,
  clustering_coefficient = clustering_coefficient
)


print(network_stats_summary)


influencers <- network_stats_summary %>%
  arrange(desc(betweenness)) %>%
  head(3) 
print(influencers)
```


```{r}
# Check for isolated nodes
isolates <- which(degree(g_subset) == 0)
if (length(isolates) > 0) {
  print(V(g_subset)$name[isolates])
}

# Check if the graph is fully connected
is.fully.connected <- is.connected(g_subset)
print(is.fully.connected)

# Check if the graph is directed
is.directed <- is_directed(g_subset)
print(is.directed)

```


```{r}
in_degree_stats <- degree(g_subset, mode = "in")
out_degree_stats <- degree(g_subset, mode = "out")
total_degree_stats <- in_degree_stats + out_degree_stats
rbind(in_degree_stats, out_degree_stats, total_degree_stats)

```

```{r}
interactions$time<-as.numeric(interactions$time) 


# Create the REM data set
REM.data <- createRemDataset(
  data = interactions, 
  sender = interactions$sender_id,
  target = interactions$receiver_id,
  eventSequence = interactions$time,
  eventAttribute = interactions$dialog,
  atEventTimesOnly = TRUE, 
  untilEventOccurrs = TRUE,
  includeAllPossibleEvents = FALSE, 
  returnInputData = FALSE
)

# Check the structure of the REM.data
str(REM.data)
```



```{r}
head(REM.data)
```



```{r}
#save as RDS
#saveRDS(REM.data, "data/REM_data_onlyevent.RDS")

readRDS("data/REM_data_onlyevent.RDS") -> REM.data

```


```{r}
library(survival)
library(rem)


surv_object <- Surv(time = REM.data$eventTime, event = REM.data$eventDummy)


cox_model <- coxph(surv_object ~ sender + target, data = REM.data)


summary(cox_model)

```

```{r}

model2_event <- coxph(surv_object ~ eventAttribute, data = REM.data)
summary(model2_event)
```

```{r}

model3_snd_event <- coxph(surv_object ~ sender + eventAttribute, data = REM.data)
summary(model3_snd_event)
```


```{r}

surv_object2 <- Surv(time = REM.data$eventTime, event = REM.data$eventDummy)

```


